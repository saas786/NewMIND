---
type: paper
tags: 📥️/📜️/🩳/🗿
aliases:
  - 
cssclass: 
---



# Title: **[[Случайные числа 2021-09-26]]**
- `Type:` [[&]]
- `Links:`
- `Reviewed Date:` [[2021-09-26]]

## Генерация случайных чисел через `keccak256`

Лучший способ создать источник случайностей в Solidity — хэш-функция `keccak256`.

Можно написать код вроде такого:

```solidity
// Сгенерировать случайное число от 1 до 100:
uint randNonce = 0;
uint random = uint(keccak256(now, msg.sender, randNonce)) % 100;
randNonce++;
uint random2 = uint(keccak256(now, msg.sender, randNonce)) % 100;
```

Эта функция берет временную метку `now`, `msg.sender` и добавочный `nonce` (nonce - число, используемое только один раз, поэтому не запускают дважды хэш-функцию с одним и тем же наборов входных данных).

Затем она использует `keccak` для преобразования входных данных в случайный хэш, конвертирует этот хэш в `uint`, далее выполняет `%100`, чтобы взять только последние 2 цифры. Эта процедура дает нам абсолютно случайное число от 0 до 100.

### Этот метод уязвим перед типом атаки, известным как «нечестная нода»

Когда ты вызываешь функцию в контракте Ethereum, то транслируешь ее ноде или нодам в сети как **_транзакцию_**. Ноды в сети собирают много транзакций вместе и стараются первыми найти решение сложной математической задачи, чтобы получить «Доказательство работы». Затем они публикуют в сети эту группу транзакций и доказательство работы (PoW) как **_блок_**.

Как только нода решила задачу и получила PoW, другие ноды перестают решать эту задачу, проверяют валидность списка транзакций решившей ноды, принимают блок и включают его в блокчейн. Затем приступают к поиску решения задачи для следующего блока.

**Теоретически из-за этого функцию случайных чисел можно взломать.**

Представим, что существует контракт игры типа «орел-решка» - если выпадает орел, то активы удваиваются, если выпадает решка, то игрок теряет все. Предположим, что функция определяет выпадение орла и решки. (`random >= 50` - орел, `random <50` - решка).

Если человек держит ноду, то он может опубликовать транзакцию **только в своей собственной ноде** и не делиться ей ни с кем. Он может запустить функцию подбрасывания монеты, чтобы увидеть результат — орел или решка — и не включать транзакцию в следующий блок при проигрыше. Можно продолжать делать это бесконечно, пока не выпадет нужная сторона монеты, и эту транзакцию уже включить в следующий блок — профит!